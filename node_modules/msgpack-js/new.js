


exports.decode = function (buffer) {
  var decoder = new Decoder(buffer);
  return decoder.parse();
}

function Decoder(buffer) {
  this.buffer = buffer;
  this.offset = 0;
}

Decoder.prototype.map = function (length) {
  var value = {};
  for (var i = 0; i < length; i++) {
    value[this.parse()] = this.parse();
  }
  return value;
};
Decoder.prototype.array = function (length) {
  var value = new Array(length);
  for (var i = 0; i < length; i++) {
    value[i] = this.parse();
  }
  return value;
};
Decoder.prototype.buf = function (length) {
  throw new Error("TODO: Implement buf decoder");
};
Decoder.prototype.raw = function (length) {
  var value = this.buffer.toString('ascii', this.offset, this.offset + length);
  this.offset += length;
  return value;
};
Decoder.prototype.parse = function () {
  var type = this.buffer[this.offset];
  var length, value;
  // FixRaw
  if ((type & 0xe0) === 0xa0) {
    this.offset++;
    return this.raw(type & 0x1f);
  }
  // FixMap
  if ((type & 0xf0) === 0x80) {
    this.offset++;
    return this.map(type & 0x0f);
  }
  // FixArray
  if ((type & 0xf0) === 0x90) {
    this.offset++;
    return this.array(type & 0x0f);
  }
  // raw 16
  if (type === 0xda) {
    length = this.buffer.readUInt16BE(this.offset + 1);
    this.offset += 3;
    return this.raw(length);
  }
  // Positive FixNum
  if ((type & 0x80) === 0x00) {
    this.offset++;
    return type;
  }
  // uint 16
  if (type === 0xcd) {
    value = this.buffer.readUInt16BE(this.offset + 1);
    this.offset += 3;
    return value;
  }
  // nil
  if (type === 0xc0) {
    this.offset++;
    return null;
  }
  // false
  if (type === 0xc2) {
    this.offset++;
    return false;
  }
  // true
  if (type === 0xc3) {
    this.offset++;
    return true;
  }
  
  
  throw new Error("Unknown type 0x" + type.toString(16));
  
};

